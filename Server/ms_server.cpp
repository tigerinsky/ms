// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <pthread.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PosixThreadFactory.h>
#include <thrift/server/TNonblockingServer.h>

#include "glog/logging.h"
#include "mysql_proxy.h"
#include "../Handler/message_server_handler.h"
#include "../ms_flag.h"
#include "ms_server.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;

using boost::shared_ptr;

namespace tis {

MsServer::MsServer() {
    _server = NULL;
}

MsServer::~MsServer() {
    if (_server) {
        delete _server;
        _server = NULL;
    }
}

int MsServer::init() {
    //初始化日志
    FLAGS_logbuflevel = 5;
    google::InitGoogleLogging("ms");

    //全局初始化mysql_proxy
    MysqlProxy::library_init();
    LOG(INFO) << "ms server init ok!\n";
    return 0;
}

int MsServer::run() {
    // processor
    shared_ptr<MessageServerHandler> handler(new MessageServerHandler());
    shared_ptr<TProcessor> processor(new MessageServerProcessor(handler));
    if (MessageServerHandler::init_thread_data(FLAGS_server_thread_num)) {
        LOG(ERROR) << "init thread space error";
        return 1;
    }

    // protocol
    shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

    // thread pool
    shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(FLAGS_server_thread_num);
    shared_ptr<PosixThreadFactory> threadFactory(new PosixThreadFactory());
    threadManager->threadFactory(threadFactory);
    threadManager->start();

    // server
    _server = new(std::nothrow) TNonblockingServer(processor,
                                                   protocolFactory,
                                                   FLAGS_server_port,
                                                   threadManager);
    if (NULL == _server) {
        LOG(ERROR) << "ms create nonblocking server error";
        return 1;
    }
    _server->serve();

    /*shared_ptr<TServerTransport> serverTransport(new TServerSocket(FLAGS_server_port));
    shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
    shared_ptr<ThreadManager> threadManager(ThreadManager::newSimpleThreadManager(FLAGS_server_thread_num));
    shared_ptr<PosixThreadFactory> threadFactory(new PosixThreadFactory());
    threadManager->threadFactory(threadFactory);
    threadManager->start();
    _server = new(std::nothrow) TThreadPoolServer(processor, serverTransport, transportFactory, protocolFactory, threadManager);
    _server->serve();*/
    LOG(INFO) << "ms start ok!\n";
    return 0;
}

void MsServer::stop() {
    if (_server) {
        _server->stop();
    }
    MysqlProxy::library_end();
}

}

